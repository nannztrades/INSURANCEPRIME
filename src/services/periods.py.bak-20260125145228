# src/services/periods.py
from __future__ import annotations
import re
from calendar import month_abbr

def to_period_key(label: str) -> str:
    """
    Convert a variety of month labels to canonical 'YYYY-MM'.
    Accepts: 'Jun 2025', 'June 2025', '2025-06', 'COM_JUN_2025', 'COM_June_2025',
             '2025/6', '2025.6', '2025.06', 'JUN 2025', etc.
    Returns: 'YYYY-MM' or raises ValueError if not understood.
    """
    if not label:
        raise ValueError("Empty month label")

    s = str(label).strip()

    # Already YYYY-MM
    if re.fullmatch(r"\d{4}-\d{2}", s):
        return s

    # Normalize common COM_*, underscores and hyphens to spaces, then parse MonthName Year
    s_norm = re.sub(r"^COM[_\-\s]+", "", s, flags=re.IGNORECASE)
    s_norm = re.sub(r"[_\-]+", " ", s_norm).strip()

    # 'June 2025' / 'Jun 2025' / 'JUN 2025'
    m = re.fullmatch(r"([A-Za-z]{3,})\s+(\d{4})", s_norm)
    if m:
        mon_word, year = m.group(1), m.group(2)
        mon3 = mon_word[:3].title()  # Jun, Dec, etc.
        try:
            month = list(month_abbr).index(mon3)
        except ValueError:
            raise ValueError(f"Unrecognized month name in '{label}'")
        return f"{year}-{month:02d}"

    # '2025/06' or '2025.6'
    m = re.fullmatch(r"(\d{4})[./](\d{1,2})", s)
    if m:
        return f"{m.group(1)}-{int(m.group(2)):02d}"

    # Fallback: last resort try to sniff Month + Year in any order
    m = re.search(r"([A-Za-z]{3,})\s*[_\-\s]+\s*(\d{4})", s)
    if m:
        mon3 = m.group(1)[:3].title()
        year = m.group(2)
        try:
            month = list(month_abbr).index(mon3)
        except ValueError:
            raise ValueError(f"Unrecognized month name in '{label}'")
        return f"{year}-{month:02d}"

    raise ValueError(f"Cannot parse month label '{label}'")