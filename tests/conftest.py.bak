
# tests/conftest.py
# Pytest fixtures & monkeypatches for hermetic tests + robust import resolution.

from __future__ import annotations

# ──────────────────────────────────────────────────────────────────────────────
# Make <repo>/src importable in tests and visible to Pylance
# ──────────────────────────────────────────────────────────────────────────────
import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]     # d:/PROJECT/INSURANCELOCAL
SRC = ROOT / "src"
if str(SRC) not in sys.path:
    sys.path.insert(0, str(SRC))

# ──────────────────────────────────────────────────────────────────────────────
# Standard imports (now that src is on sys.path)
# ──────────────────────────────────────────────────────────────────────────────
import importlib
from typing import Any
import pytest
from fastapi import FastAPI, HTTPException, Request
from fastapi.testclient import TestClient


# =============================================================================
# Fake DB connection + cursor
# =============================================================================
class FakeCursor:
    def __init__(self) -> None:
        self._lastrowid = 1
        self._result: list[dict[str, Any]] = []
        self._one: dict[str, Any] | None = None
        self._sql = ""

    @property
    def lastrowid(self) -> int:
        return self._lastrowid

    def execute(self, sql: str, params: tuple | list | None = None) -> None:
        self._sql = sql
        params = tuple(params or ())
        s = " ".join(sql.split()).lower()

        # Default: no rows
        self._result = []
        self._one = None

        # Minimal patterns used by the current API tests
        if "from `users`" in s:
            # Simulate one active user for happy-path auth tests
            if "where `agent_code`" in s and "and `role`='agent'" in s:
                self._one = {
                    "id": 101,
                    "email": "agent@example.com",
                    "role": "agent",
                    "agent_code": params[0] if params else "AG001",
                    "agent_name": "Agent One",
                    "is_active": 1,
                    "password_hash": "hash",
                }
            elif "where `id`=" in s:
                self._one = {
                    "id": params[0] if params else 201,
                    "email": "admin@example.com",
                    "role": "admin",
                    "agent_code": None,
                    "agent_name": None,
                    "is_active": 1,
                    "password_hash": "hash",
                }
        elif "from `uploads`" in s:
            self._result = []
        elif "from `statement`" in s:
            self._result = []
        elif "from `schedule`" in s:
            self._result = []
        elif "from `terminated`" in s:
            self._result = []
        elif "from `active_policies`" in s:
            self._result = []
        elif "from `audit_flags`" in s:
            self._result = []

    def executemany(self, sql: str, params_seq) -> None:
        self._lastrowid += len(list(params_seq))

    def fetchall(self) -> list[dict[str, Any]]:
        return self._result

    def fetchone(self) -> dict[str, Any] | None:
        return self._one

    def __enter__(self) -> "FakeCursor":
        return self

    def __exit__(self, exc_type, exc, tb) -> bool:
        return False


class FakeConn:
    def __init__(self) -> None:
        self._cur = FakeCursor()

    def cursor(self) -> FakeCursor:
        return self._cur

    def commit(self) -> None:
        pass

    def close(self) -> None:
        pass


# =============================================================================
# Shared fixtures (autouse monkeypatching + app + client)
# =============================================================================
@pytest.fixture(autouse=True)
def patch_internals(monkeypatch):
    """
    Make the app independent of a real DB and external auth during tests.
    Also enforce CSRF so tests catch missing header cases.
    """

    # 1) DB: get_conn -> FakeConn
    db = importlib.import_module("src.ingestion.db")
    monkeypatch.setattr(db, "get_conn", lambda: FakeConn(), raising=True)

    # 2) Roles dependencies: return predictable identities
    roles = importlib.import_module("src.services.roles")

    def require_role(*_roles):
        # Return a dependency callable
        def _dep():
            return {"role": _roles[0] if _roles else "admin"}
        return _dep

    def require_agent_user():
        return {"role": "agent", "agent_code": "AG001"}

    monkeypatch.setattr(roles, "require_role", require_role, raising=True)
    monkeypatch.setattr(roles, "require_agent_user", require_agent_user, raising=True)

    # 3) CSRF: issue a fixed token, and require header to match
    sec = importlib.import_module("src.services.security")

    def _csrf_dep_factory():
        def _inner(request: Request):
            if request.headers.get("x-csrf-token") != "csrf-test-token":
                raise HTTPException(status_code=403, detail="CSRF failed")
            return None
        return _inner

    monkeypatch.setattr(sec, "issue_csrf_token", lambda: "csrf-test-token", raising=True)
    monkeypatch.setattr(sec, "require_csrf", _csrf_dep_factory, raising=True)

    # 4) Auth service: deterministic token & password check
    auth = importlib.import_module("src.services.auth_service")

    def create_token(payload, _mins):
        role = (payload or {}).get("role", "anon")
        return f"{role}-token"

    def decode_token(token: str | None):
        if token == "agent-token":
            return {"role": "agent", "user_id": 101, "agent_code": "AG001", "agent_name": "Agent One"}
        if token == "admin-token":
            return {"role": "admin", "user_id": 201, "agent_code": None}
        if token == "superuser-token":
            return {"role": "superuser", "user_id": 301}
        return None

    def verify_and_upgrade_password(password: str, _hash: str):
        # Accept only 'pass123' as valid in tests
        return (password == "pass123", None)

    monkeypatch.setattr(auth, "create_token", create_token, raising=True)
    monkeypatch.setattr(auth, "decode_token", decode_token, raising=True)
    monkeypatch.setattr(auth, "verify_and_upgrade_password", verify_and_upgrade_password, raising=True)


@pytest.fixture(scope="session")
def app() -> FastAPI:
    """
    Build a FastAPI app that includes the routers under test.
    """
    from src.api import (
        admin_reports,
        agent_api,
        superuser_api,
        uploads,
        uploads_secure,
        ingestion_api,
        agent_reports,
        agent_missing,
        disparities,
        ui_pages,
        admin_users,
        admin_agents,
        auth_api,
    )

    app = FastAPI(title="ICRS Test App")
    app.include_router(uploads.router)
    app.include_router(uploads_secure.router)
    app.include_router(ingestion_api.router)
    app.include_router(agent_reports.router)   # NOTE: no extra prefix to avoid /api/api/ paths
    app.include_router(disparities.router)
    app.include_router(agent_missing.router)
    app.include_router(admin_reports.router)
    app.include_router(agent_api.router)
    app.include_router(superuser_api.router)
    app.include_router(admin_users.router)
    app.include_router(admin_agents.router)
    app.include_router(auth_api.router)
    app.include_router(ui_pages.router)
    return app


@pytest.fixture()
def client(app: FastAPI) -> TestClient:
    return TestClient(app)
